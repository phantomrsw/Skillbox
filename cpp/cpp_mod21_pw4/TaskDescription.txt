Задание 4. Реализация ролевой пошаговой игры (дополнительное задание)
Что нужно сделать:
Реализуйте сильно упрощённую версию ролевой пошаговой игры.
Игра происходит на карте размером 20 на 20 клеток. По клеткам перемещаются враги и персонаж игрока.
После каждого хода игрока карта показывается вновь со всеми врагами на ней. Игрок помечается буквой P,
враги — буквой E, пустые места — точкой.
Каждый персонаж игры представлен в виде структуры с полями: имя, жизни, броня, урон.
Вначале игры создаются 5 случайных врагов в случайных клетках карты. Имена врагам задаются в формате
Enemy #N, где N — это порядковый номер врага. Уровень жизней врагам задаётся случайно — от 50 до 150.
Уровень брони варьируется от 0 до 50. Урон тоже выбирается случайно — от 15 до 30 единиц.
Игрок конструирует своего персонажа самостоятельно. Задаёт все его параметры, включая имя.
Все персонажи появляются в случайных местах карты.
Игрок осуществляет ход с помощью следующих команд: w, a, s, d. В зависимости от команды выбирается
направление перемещения персонажа: влево, вправо, вверх, вниз.
Враги перемещаются в случайном направлении.
Если персонаж (враг или игрок) перемещается в сторону, где уже находится какой-то персонаж, то он бьёт
этого персонажа с помощью своего урона. Враги при этом никогда не бьют врагов, а просто пропускают ход
и остаются на своём месте. За пределы карты (20 на 20 клеток) ходить нельзя никому. Если кто-то выбрал
направление за гранью дозволенного, ход пропускается.
Формула для расчёта урона совпадает с той, что была в занятии. Жизни уменьшаются на оставшийся после
брони урон. При этом броня тоже сокращается на приведённый урон.
Игра заканчивается тогда, когда либо умирают все враги, либо персонаж игрока. В первом случае на экран
выводится сообщение о поражении, во втором — победа.
Если в начале хода игрок вводит команду save или load вместо направления перемещения, то игра либо
делает сохранение своего состояния в файл, либо загружает это состояние из файла соответственно.

Советы и рекомендации:
Для определения команды персонажа можно завести специальный флаг внутри структуры данных персонажа.
Для отображения координат персонажей можете использовать структуру вектора из другой задачи, но заменить
типы координат.
Для сохранения параметров игры и их загрузки можно работать с текстовыми данными. Однако записать в
двоичном формате куда проще, главное соблюдать последовательность полей:

std::ofstream file("save.bin", std::ios::binary);
    for (int i = 0; i < 6; ++i) {
        file.write((char*)&(characters[i].position),
                   sizeof(characters[i].position));
…

При загрузке используйте ifstream и ту же последовательность полей.

Что оценивается:
Корректно работает сохранение и загрузка в игре.
После загрузки все атрибуты игрока, включая имя, восстанавливаются из файла.
После загрузки количество противников на игровом поле соответствует количеству противников при сохранении.
Все игроки после загрузки появляются на координатах, в которых они находились при сохранении.
При ходе игрока не происходит появления новых противников.
Перед загрузкой файла сохранения проверяется его наличие в операционной системе.
Как отправить работу на проверку
Пришлите ссылку на repl.it или файл CPP с решением через форму ниже.

